package ai.acyclic.six.typetag

import ai.acyclic.six.lower.JavaLowering
import dotty.tools.dotc.ast.tpd
import dotty.tools.dotc.core.Contexts.Context
import dotty.tools.dotc.core.{Contexts, Types}
import dotty.tools.dotc.printing.{Printer, ReplPrinter}
import dotty.tools.dotc.quoted.PickledQuotes

import scala.language.implicitConversions
import scala.quoted.*
import scala.quoted.runtime.impl.{QuotesImpl, SpliceScope, TypeImpl}
import scala.runtime.ScalaRunTime

case class TypeTag[T](tastyBinary: List[String])(
    @transient typeTreeAtCreation: tpd.Tree = null, // will be discarded after compilation
    @transient ctxAtCreation: Context = null
) extends Serializable {

  // not serializable
  case class AtContext()(
      using
      ctx: Context
  ) {

    lazy val typeTree: tpd.Tree = {
      Option(typeTreeAtCreation).getOrElse {

        val tree = PickledQuotes.unpickleTypeTree(tastyBinary, PickledQuotes.TypeHole.V2(null))
        tree
      }
    }

    def rebuild(): TypeTag[T] = {
      TypeTag[T](tastyBinary)(typeTree, ctx)
    }

    lazy val dottyType: Types.Type = typeTree.typeOpt

    lazy val quotedType: Type[T] & TypeImpl = {

      new TypeImpl(typeTree, SpliceScope.getCurrent).asInstanceOf[Type[T] & TypeImpl]
    }

    lazy val className: String = {

      AtCreation.dottyType.classSymbol.binaryClassName
    }

    object Printers {

      val builtIn: Printer = ctx.printer
      val noColor = new ReplPrinter(ctx)

      extension (p: Printer) {
        def showString: String = {

          import dotty.tools.dotc.core.Decorators.show

          p.toText(typeTreeAtCreation).show
        }
      }
    }

  }

  @transient private val AtCreation = AtContext()(
    using
    ctxAtCreation
  )

  case class InStage(stage: staging.Compiler) {

    lazy val rebuild: TypeTag[T] = {

      stage.run[TypeTag[T]] {
        case q: QuotesImpl =>
          given Quotes = q

          val atCtx = AtContext()(
            using
            q.ctx
          )

          val result: TypeTag[T] = atCtx.rebuild()

          given Type[T] = atCtx.quotedType

          TypeTag.lowering[T].apply(result)

        // TODO: this should work
//          '{ $result }
      }
    }
  }

  object InDefaultStage extends InStage(TypeTag.defaultRuntimeStage)

  import AtCreation.Printers.*

  val toString_builtIn: String = {

    builtIn.showString
  }

  override val toString: String = {

    noColor.showString
  }

  private val runtimeClassName: String = {

    AtCreation.className
  }

  @transient lazy val runtimeClass: Class[T] = Class.forName(runtimeClassName).asInstanceOf[Class[T]]
}

object TypeTag {

  lazy val defaultRuntimeStage: staging.Compiler = staging.Compiler.make(ClassLoader.getSystemClassLoader)

//  lazy val currentContext = currentStage.run { q =>
//    given Quotes = q
//    val ctx: Context = q.asInstanceOf[QuotesImpl].ctx
//    ctx
//  }

  implicit def lowering[T](
      using
      Type[TypeTag[T]]
  ): ToExpr[TypeTag[T]] = JavaLowering.Implicits.only[TypeTag[T]]

  def compile[T]()(
      using
      Type[T],
      Quotes
  ): Expr[TypeTag[T]] = {

    val tt = implicitly[Type[T]]
    val qq = implicitly[Quotes]

    val raw: TypeTag[T] = (tt, qq) match {

      case (t: TypeImpl, q: QuotesImpl) =>
        given ctx: Context = q.ctx

        val tree = t.typeTree
        val pickle: List[String] = PickledQuotes.pickleQuote(tree)
        val raw = TypeTag[T](pickle)(tree, ctx)

        raw
      case _ =>
        ???
    }

    Expr.apply[TypeTag[T]](raw)(
      using
      lowering
    )
  }

  inline given get[T]: TypeTag[T] = ${ compile[T]() }

//  def unpickleDemo(bytes: Array[Byte])( // generated by Claude 3.5
//      using
//      Quotes
//  ): Unit =
//    val ctx: Context = summon[Quotes].reflect.rootContext.asInstanceOf[Context]
//
//    val unpickler = new DottyUnpickler(bytes)
//    unpickler.enter()(
//      using
//      ctx
//    )
//
//    // Access unpickled information
//    val tree = unpickler.tree
//    println(s"Unpickled tree: $tree")
}
